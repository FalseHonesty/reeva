package me.mattco.reeva.lexer

enum class TokenType(val category: Category, val meta: String? = null) {
    Ampersand(Category.Operator, "&"),
    AmpersandEquals(Category.Operator, "&="),
    Arrow(Category.Operator, "=>"),
    Asterisk(Category.Operator, "*"),
    AsteriskEquals(Category.Operator, "*="),
    Caret(Category.Operator, "^"),
    CaretEquals(Category.Operator, "^="),
    DoubleAmpersand(Category.Operator, "&&"),
    DoubleAmpersandEquals(Category.Operator, "&&="),
    DoubleAsterisk(Category.Operator, "**"),
    DoubleAsteriskEquals(Category.Operator, "**="),
    DoubleEquals(Category.Operator, "=="),
    DoublePipe(Category.Operator, "||"),
    DoublePipeEquals(Category.Operator, "||="),
    DoubleQuestion(Category.Operator, "??"),
    DoubleQuestionEquals(Category.Operator, "??="),
    Equals(Category.Operator, "="),
    Exclamation(Category.Operator, "!"),
    ExclamationDoubleEquals(Category.Operator, "!=="),
    ExclamationEquals(Category.Operator, "!="),
    GreaterThan(Category.Operator, ">"),
    GreaterThanEquals(Category.Operator, ">="),
    LessThan(Category.Operator, "<"),
    LessThanEquals(Category.Operator, "<="),
    Minus(Category.Operator, "-"),
    MinusEquals(Category.Operator, "-="),
    MinusMinus(Category.Operator, "--"),
    Percent(Category.Operator, "%"),
    PercentEquals(Category.Operator, "%="),
    Period(Category.Operator, "."),
    Pipe(Category.Operator, "|"),
    PipeEquals(Category.Operator, "|="),
    Plus(Category.Operator, "+"),
    PlusEquals(Category.Operator, "+="),
    PlusPlus(Category.Operator, "++"),
    Question(Category.Operator, "?"),
    QuestionPeriod(Category.Operator, "?."),
    ShiftLeft(Category.Operator, "<<"),
    ShiftLeftEquals(Category.Operator, "<<="),
    ShiftRight(Category.Operator, ">>"),
    ShiftRightEquals(Category.Operator, ">>="),
    Slash(Category.Operator, "/"),
    SlashEquals(Category.Operator, "/="),
    Tilde(Category.Operator, "~"),
    TripleDot(Category.Operator, "..."),
    TripleEquals(Category.Operator, "==="),
    UnsignedShiftRight(Category.Operator, ">>>"),
    UnsignedShiftRightEquals(Category.Operator, ">>>="),

    CloseBracket(Category.Punctuation, "]"),
    CloseCurly(Category.Punctuation, "}"),
    CloseParen(Category.Punctuation, ")"),
    Colon(Category.Punctuation, ":"),
    Comma(Category.Punctuation, ","),
    OpenBracket(Category.Punctuation, "["),
    OpenCurly(Category.Punctuation, "{"),
    OpenParen(Category.Punctuation, "("),
    Semicolon(Category.Punctuation, ";"),

    Async(Category.Keyword, "async"),
    Await(Category.Keyword, "await"),
    Break(Category.Keyword, "break"),
    Case(Category.FlowKeyword, "case"),
    Catch(Category.FlowKeyword, "catch"),
    Class(Category.Keyword, "class"),
    Const(Category.Keyword, "const"),
    Continue(Category.FlowKeyword, "continue"),
    Debugger(Category.Keyword, "debugger"),
    Default(Category.Keyword, "default"),
    Delete(Category.Keyword, "delete"),
    Do(Category.FlowKeyword, "do"),
    Else(Category.FlowKeyword, "else"),
    Enum(Category.Keyword, "enum"),
    Export(Category.Keyword, "export"),
    Extends(Category.Keyword, "extends"),
    False(Category.Keyword, "false"),
    Finally(Category.FlowKeyword, "finally"),
    For(Category.FlowKeyword, "for"),
    Function(Category.Keyword, "function"),
    If(Category.FlowKeyword, "if"),
    Import(Category.Keyword, "import"),
    In(Category.Keyword, "in"),
    Instanceof(Category.Keyword, "instanceof"),
    Interface(Category.Keyword, "interface"),
    Let(Category.Keyword, "let"),
    New(Category.Keyword, "new"),
    NullLiteral(Category.Keyword, "null"),
    Of(Category.Keyword, "of"),
    Return(Category.FlowKeyword, "return"),
    Super(Category.Keyword, "super"),
    Switch(Category.FlowKeyword, "switch"),
    This(Category.Keyword, "this"),
    Throw(Category.FlowKeyword, "throw"),
    True(Category.Keyword, "true"),
    Try(Category.FlowKeyword, "try"),
    Typeof(Category.Keyword, "typeof"),
    Var(Category.Keyword, "var"),
    Void(Category.Keyword, "void"),
    While(Category.FlowKeyword, "while"),
    With(Category.FlowKeyword, "with"),
    Yield(Category.FlowKeyword, "yield"),

    BigIntLiteral(Category.Number),
    NumericLiteral(Category.Number),
    BooleanLiteral(Category.Keyword),
    TemplateLiteralStart(Category.String),
    TemplateLiteralEnd(Category.String),
    TemplateLiteralExprStart(Category.Punctuation),
    TemplateLiteralExprEnd(Category.Punctuation),
    TemplateLiteralString(Category.String),

    RegexFlags(Category.String),
    RegexLiteral(Category.String),
    StringLiteral(Category.String),
    UnterminatedStringLiteral(Category.String),
    UnterminatedTemplateLiteral(Category.String),
    UnterminatedRegexLiteral(Category.String),

    Identifier(Category.Identifier),

    Eof(Category.Invalid),
    Invalid(Category.Invalid);

    enum class Category {
        Operator,
        Punctuation,
        Keyword,
        String,
        FlowKeyword,
        Number,
        Identifier,
        Invalid,
    }

    companion object {
        val keywords = values().filter { it.category == Category.Keyword || it.category == Category.FlowKeyword }
        val tripleCharTokens = values().filter { it.meta?.length == 3 && it !in keywords }
        val doubleCharTokens = values().filter { it.meta?.length == 2 && it !in keywords }
        val singleCharTokens = values().filter { it.meta?.length == 1 && it !in keywords }
    }
}
